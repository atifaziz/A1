<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
#region Copyright (c) 2016 Atif Aziz. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
#endregion

// This code was generated by a tool. Any changes made manually will be lost
// the next time this code is regenerated.
// Generated: <#= DateTime.Now.ToString("r") #>

namespace A1
{
    using System;
<#  foreach (var c in new[] { "Row", "Col" })
    {
        var n = c.ToLowerInvariant(); #>

    partial struct <#= c #> : IEquatable<<#= c #>>, IComparable<<#= c #>>
    {
        public static readonly <#= c #> First = default(<#= c #>);

        public int Offset { get; }
        int Number => Offset + 1;

        public static <#= c #> FromOffset(int offset) => new <#= c #>(offset + 1);

        public <#= c #>(int n)
        {
            if (n < 1) throw new ArgumentOutOfRangeException(nameof(n));
            Offset = n - 1;
        }

        public bool Equals(<#= c #> other) => Offset == other.Offset;
        public override bool Equals(object obj) => obj is <#= c #> && Equals((<#= c #>) obj);
        public override int GetHashCode() => Offset;

        public int CompareTo(<#= c #> other) => Offset.CompareTo(other.Offset);

        public override string ToString() => Number.ToString();

        public static <#= c #> operator +(<#= c #> <#= n #>, int n) => new <#= c #>(<#= n #>.Number + n);
        public static <#= c #> operator -(<#= c #> <#= n #>, int n) => new <#= c #>(<#= n #>.Number - n);
        public static int operator -(<#= c #> a, <#= c #> b) => a.Offset - b.Offset;
        public static <#= c #> operator ++(<#= c #> <#= n #>) => <#= n #> + 1;
        public static <#= c #> operator --(<#= c #> <#= n #>) => <#= n #> - 1;

        public static bool operator ==(<#= c #> left, <#= c #> right) => left.Equals(right);
        public static bool operator !=(<#= c #> left, <#= c #> right) => !left.Equals(right);

        public static explicit operator <#= c #>(int value) => new <#= c #>(value);
        public static implicit operator int(<#= c #> <#= n #>) => <#= n #>.Number;
    }
<# } #>
}
